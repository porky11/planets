(import gl)
(import glut)
(import spatial)
(import util)
(import sequence-math)

(import utility)
(import stdlib)
(import cstdio)
(import math)
(import unique-ptr)
(import macros)
(import concept-defs)
(import concepts)
(import derivations)
(import array)
(import vector)
(import assert)


(def pressed (var intern (array-of 256 bool)))

(def is-pressed (fn intern bool ((key char))
  (@$ pressed key)))

(def press (fn intern void ((key char))
  (setf ($ pressed key) true)))

(def release (fn intern void ((key char))
  (setf ($ pressed key) false)))

(def gravity (var intern float 0.00000))




(using-namespace std.macros
(using-namespace std.concepts
  (implement BasicMath float)

  (instantiate Array float 2)
  (instantiate + (Array float 2))
  (instantiate - (Array float 2))
  (instantiate * (Array float 2))
  (instantiate / (Array float 2))


  (def-type-macro2 Ball)
  (def-concept-macro Ball intern ((T Type) (N Value))
    (qq do
      (def (Ball (uq T) (uq N))
        (struct intern
          ((pos (Array (uq T) (uq N)))
           (force (Array (uq T) (uq N)))
           (mass (uq T))
           (r (uq T)))))
      (def = (fn intern bool ((p0 (ref (Ball (uq T) (uq N)))) (p1 (ref (Ball (uq T) (uq N)))))
        (p= p0 p1)))
      (def != (fn intern bool ((p0 (ref (Ball (uq T) (uq N)))) (p1 (ref (Ball (uq T) (uq N)))))
        (not (p= p0 p1))))
      (def pos (macro intern ((Ball (Ball (uq T) (uq N))))
        (qq : (uq (uq Ball)) pos)))
      (def force (macro intern ((Ball (Ball (uq T) (uq N))))
        (qq : (uq (uq Ball)) force)))
      (implement Struct (Ball (uq T) (uq N)))
      (implement EqualityComparable (Ball (uq T) (uq N)))))

  (def-concept-macro collide intern ((T Type))
    (qq using-namespace std
      (def collide (fn intern void ((p0 (ref (uq T))) (p1 (ref (uq T))))
        (let ((disvec \ (- (@:@ p0 pos) (@:@ p1 pos)))
              (dis2 \ (+ (pow (@$ disvec 0) 2.0) (pow (@$ disvec 1) 2.0)))
              (dis \ (sqrt dis2))
              (rs \ (+ (@:@ p0 r) (@:@ p1 r)))
              (st \ 0.125)
              (acc \ (* disvec (/ (* 1.0 gravity) (* dis dis2)))))
         ;(printf "%f\n" (@$ acc 0))
          (if (< dis (* 1.0 rs))
              (incf (# acc) (* disvec (* st (/ (- dis rs) dis))))
              0)
          (incf (force p1) acc)
          (decf (force p0) acc))))))
  (def-concept-macro whatever intern ((T Type))
    (qq do
      (def = (fn intern bool ((p0 (ref (const (UniquePtr (uq T)))))
                              (p1 (ref (const (UniquePtr (uq T))))))
        (p= p0 p1)))
      (def != (fn intern bool ((p0 (ref (const (UniquePtr (uq T)))))
                               (p1 (ref (const (UniquePtr (uq T))))))
        (not (p= p0 p1))))
      (implement EqualityComparable (UniquePtr (uq T)))
      (instantiate swap (UniquePtr (uq T)))
      (implement Swappable (UniquePtr (uq T)))
      (instantiate Vector (UniquePtr (uq T)))))

  (def-type-macro Connection)
  (def-concept-macro Connection intern ((T Type))
    (qq using-namespace std
      (using-namespace std.concepts
        (def (Connection (uq T))
          (struct intern ((object0 (uq T)) (object1 (uq T))
                          (length float)
                          (strength float))))
        (implement MoveConstructible (Connection (uq T)))
        (def act (fn intern void ((conn (Connection (uq T))))
          (let ((p0 \ (@: conn object0))
                (p1 \ (@: conn object1))
                (rs \ (@: conn length))
                (st \ (@: conn strength))
                (disvec \ (- (@:@ p0 pos) (@:@ p1 pos)))
                (dis2 \ (+ (pow (@$ disvec 0) 2.0) (pow (@$ disvec 1) 2.0)))
                (dis \ (sqrt dis2))
                (acc \ (* disvec (* (/ (- dis rs) dis) st))))
            (printf "%f, %f\n" (@$ acc 0) (@$ acc 1))
            (incf (:@ p1 force) acc)
            (decf (:@ p0 force) acc)))))))


  (def-type-macro Cluster)
  (def-concept-macro Cluster intern ((T Type))
    (qq do
      (using-namespace std.concepts
        (implement Vector (uq T))
      )
      (def (Cluster (uq T))
        (struct intern ((vector (Vector (uq T))))))))

  (instantiate Ball float 2)
  (def-ptr-macro pos intern (Ball float 2))
  (def-ptr-macro force intern (Ball float 2))
  (instantiate collide (Ball float 2))
  (def-ptr-macro2 collide intern (Ball float 2))
  (instantiate UniquePtr (Ball float 2))
  (instantiate whatever (Ball float 2))

  (implement Type (p (Ball float 2)))
  (instantiate Connection (p (Ball float 2)))
  
  (instantiate Vector (Connection (p (Ball float 2))))


))



#|
(using-namespace std.macros
;;(macro-print ok-ptr-macro)

;;(def-ptr-macro2 + intern (Array float 2))
;;(macro-print ok-ptr-macro2)

)
|#


(def world (var intern (Vector (UniquePtr (Ball float 2)))))

(def player (var intern (p (Ball float 2))))

(def connections (var intern (Vector (Connection (p (Ball float 2))))))

(def pi (macro intern (void)
  (q 3.14159265358979323846)))

(using-namespace std
(def init-circle (fn intern void ((circle (p (array-of 32 (array-of 2 float)))))
  (for (i int 0) (< i 32) (incv i)
    (setf ($ (@ ($ (@ circle) i)) 0) (cos (*' (/ (pi) 16.0) i)))
    (setf ($ (@ ($ (@ circle) i)) 1) (sin (*' (/ (pi) 16.0) i)))))))


(def circle (var intern (array-of 32 (array-of 2 float))))

(def max (fn intern int ((x int) (y int))
  (if (> x y) x y)))
(def min (fn intern int ((x int) (y int))
  (if (< x y) x y)))

(def init-world (fn intern void (void)
  (using-namespace std
    (for (i \ 0) (< i 8) (incv i)
      (let ((ball (p (Ball float 2)) (malloc' 1 (Ball float 2)))
            (up-ball (UniquePtr (Ball float 2))))
      (setf ball
        ((pos
           ((elements
              (array (* (cos (*' (/ (pi) 4.0) i)) 5.0)
                     (* (sin (*' (/ (pi) 4.0) i)) 5.0)))))
         (force
           ((elements (array 0.0 0.0))))
         ;(mass 1.0)
         (r 0.1)))
      (init up-ball ball)
      (push-back world (move up-ball))))
    (for (i \ 0) (< i 1) (incv i)
      (let ((ball (p (Ball float 2)) (malloc' 1 (Ball float 2)))
            (up-ball (UniquePtr (Ball float 2))))
      (setf ball
        ((pos
           ((elements (array 0.0 0.0))))
         (force
           ((elements (array-of 2 float (array 0.0 0.0)))))
         ;(mass 3200.0)
         (r 4.0)))
      (init up-ball ball)
      (push-back world (move up-ball)))))
  
  ;(setv player (get (@$ world 0)))
  (return)
))


(def init-world-snake (fn intern void (void)
  (using-namespace std
    (for ((i \ 0) (last \ (nullptr (Ball float 2))))
         (< i 8) (incv i)
      (let ((ball (p (Ball float 2)) (malloc' 1 (Ball float 2)))
            (up-ball (UniquePtr (Ball float 2))))
      (setf ball
        ((pos ((elements (array (*' 0.1 i) 0.0))))
         (force ((elements (array 0.0 0.0))))
         (r (sqrt (*' 0.001 (+ (min i (- 15 i)) 1))))))
      (init up-ball ball)
      (push-back world (move up-ball))
      (when (not (null last))
        (let ((conn (Connection (p (Ball float 2)))
                    ((object0 last)
                     (object1 ball)
                     (length 0.25)
                     (strength 0.25))))
          (push-back connections conn)))
     (setv last ball)
  )))
  
  (setv player (get (@$ world 7)))
))

(using-namespace gl
(def program (var intern Program))

(def init-program (fn intern void (void)
  (setv program (create-program))
  (let ((vertex-shader \ (create-shader vertex-shader))
        (fragment-shader \ (create-shader fragment-shader)))
    (shader-source vertex-shader "
      uniform vec2 cam;
      uniform vec2 pos;
      uniform float scale;
      varying vec2 p;
      varying vec2 c;
      void main(void) {
        c=gl_Vertex.xy;
        p=c*scale+pos;
        gl_Position = vec4(p-cam,0,1);
      }
    ")
    (compile-shader vertex-shader)
    (printf "v%i\n" (get-shader-iv vertex-shader compile-status))
    (shader-source fragment-shader "
      varying vec2 p;
      varying vec2 c;
      uniform vec2 lpos;
      void main(void) {
        vec2 ldir=normalize(lpos-p);
        float cn = max(min(1,dot(ldir,c)),0);
        gl_FragColor = vec4(
          0.0,
          cn,
          0.0,
          1
        );
      }
")
    (compile-shader fragment-shader)
    (printf "f%i\n" (get-shader-iv fragment-shader compile-status))
    (mfor s (vertex-shader fragment-shader)
      (attach-shader program s))
    (link-program program))))
)

(def x (var intern float 0.0))

(def cam (var intern float 0.0))

(def timer (fn intern void ((a int))
  ;(incf (# cam) (cond ((is-pressed (@$ "a" 0)) 0.02) ((is-pressed (@$ "d" 0)) -0.02) (true 0.00)))
  (incf ($ (@:@ player force) 0) (+ (if (is-pressed (@$ "a" 0)) -0.01 0.0)
                                    (if (is-pressed (@$ "d" 0)) 0.01 0.0)))
  (incf ($ (@:@ player force) 1) (+ (if (is-pressed (@$ "w" 0)) 0.01 0.0)
                                    (if (is-pressed (@$ "s" 0)) -0.01 0.0)))
  (in de connections
    (act (@ de)))
  (in a world
    (let ((ball \ (get (@ a))))
      (incf (:@ ball pos) (/ (@:@ ball force) (@:@ ball mass)))
      (mulf (:@ ball force) 0.8)
      ))
  (for ((b \ (begin world)) (e \ (end world))) (< b e) (setv b (successor b))
    (let ((p0 \ (get (@ (source b)))))
      (for ((b2 \ (successor b)) (e \ (end world))) (< b2 e) (setv b2 (successor b2))
          (let ((p1 \ (get (@ (source b2)))))
            (collide p0 p1) ))))
    (glutPostRedisplay)
    (glutTimerFunc (/ 1000 32) (# timer) 0)))


(using-namespace glut
(def main (fn extern-c int ((argc int) (argv (p (p char))))
  


  (init world 512)
  (init connections 512)


  (init (# argc) argv)
  (init-display-mode (| depth (| single rgba)))
  (init-window-position 100 100)
  (init-window-size 500 500)
  (create-window "test")

  (init-program)
  (init-circle (# circle))

  (init-world-snake)
  (timer 0)

  (glutKeyboardFunc (fn void ((key char) (x int) (y int))
    (printf "press\n")
    (press key)))

  (glutKeyboardUpFunc (fn void ((key char) (x int) (y int))
    (printf "release\n")
    (release key)))

  (display-func (void)
    (using-namespace gl
    (using-namespace std
      (uniform (get-uniform-location program "cam") (: (@:@ player pos) elements))
      (clear color)
      (enable-client-state vertex-array)
      (use-program program)
      (incf (# x) 0.1)
      (def y (var auto \ (/ (sqrt x) 10.0)))
      (uniform (get-uniform-location program "lpos") (* 0.25 (sin x)) (* 0.25 (cos x)))
      ;(uniform (get-uniform-location program "lpos") 0.0 0.0)
      (in a world
        (uniform (get-uniform-location program "pos") (: (@:@ (get (@ a)) pos) elements))
        (uniform (get-uniform-location program "scale") (@:@ (get (@ a)) r))
        (vertex-pointer 2 float 0 circle)
        (draw-arrays triangle-fan 0 32))
      (disable-client-state)
      (end)
      (flush))))
  (main-loop)
  (return 0)))
)
