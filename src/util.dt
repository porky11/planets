(module util)

(import macros)
(import cstdlib)
(import introspection)

#|
@macro mexit

Stops the compiliation of program.
Useful for debug reasons, when you know some error appears before this macro is expanded.

|#
(using-namespace std
(def mexit (macro extern (void)
  (exit 1)
  (q 0)))
)

(using-namespace std.macros

(def ignore (macro extern (...)
  (qq no-op)))

(def is-zero (fn extern bool ((a float))
  (= a 0.0)))

(def /0 (macro extern (x y)
  (qq if (is-zero (uq y))
    (* (uq x) (uq y))
    (/ (uq x) (uq y)))))

(def when (macro extern (con ...)
  (qq if (uq con) (do (uql (get-varargs-list (- (arg-count mc) 1)))) false)))

(def unless (macro extern (con ...)
  (qq if (uq con) false (do (uql (get-varargs-list (- (arg-count mc) 1)))))))

#|
@macro in

Uses iterators to iterate over a sequence. 

@param name will be set to a pointer of the value-type of the iterator.
@param value is a container type from which the iterator is created
|#

(ignore def in (macro extern (name value ...)
  (let ((en \ (make-gensym-var-node mc))
        (bn \ (make-gensym-var-node mc))
        (val \ (if (is-lvalue mc value) value (make-gensym-var-node mc)))
        (uql-on-empty-list-does-not-work \ (make-gensym-var-node mc)))
    (qq for ((uql (if (is-lvalue mc val) (qq (uq (make-gensym-var-node mc)) \ true)
                                            (qq (uq val) \ (uq value))))
             ((uq bn) \ (begin (uq val))) ((uq en) \ (end (uq val))))
            (< (uq bn) (uq en))
            (setv (uq bn) (successor (uq bn)))
      (let (((uq name) \ (source (uq bn))))
        (uql (get-varargs-list (- (arg-count mc) 2))))))))

(def in (macro extern (name value ...)
  (let ((en \ (make-gensym-var-node mc))
        (bn \ (make-gensym-var-node mc)))
    (qq for (((uq bn) \ (begin (uq value))) ((uq en) \ (end (uq value))))
            (< (uq bn) (uq en))
            (setv (uq bn) (successor (uq bn)))
      (let (((uq name) \ (source (uq bn))))
        (uql (get-varargs-list (- (arg-count mc) 2))))))))
)


(def def-type-macro2
  (macro extern (name)
    (let ((buf (array-of 250 char)))
      (sprintf buf "\"%s\"" (@:@ name token-str))
      (let ((string \ (std.macros.mnfv mc buf)))
        (std.macros.qq do
          (def (uq name)
            (macro extern (T U)
              (let ((typename (array-of 250 char)))
                (and (not (make-type-string mc (uq string) T U typename))
                     (return T))
                (def n (var auto (p DNode) (mnfv mc typename)))
(return n)))))))))

(using-namespace std.macros


(def def-ptr-macro (macro extern (name linkage type)
  (qq using-namespace std.macros
    (def (uq name) (macro (uq linkage) ((value (p (uq type))))
      (qq (uq name) (@ (uq (uq value)))))))))

(def def-ptr-macro2 (macro extern (name linkage type)
  (qq using-namespace std.macros
    (def (uq name) (macro (uq linkage) ((value1 (p (uq type))) (value2 (p (uq type))))
      (qq (uq name) (@ (uq (uq value1))) (@ (uq (uq value2)))))))))

(def macro-print (macro extern (object)
  (print object)
  (printf "\n")
  (qq no-op)))

(def incf (macro extern (val res)
  (let ((pos \ (make-gensym-var-node mc)))
    (qq let (((uq pos) \ (uq val)))
      (setf (uq pos) (+ (@ (uq pos)) (uq res)))))))

(def decf (macro extern (val res)
  (let ((pos \ (make-gensym-var-node mc)))
    (qq let (((uq pos) \ (uq val)))
      (setf (uq pos) (- (@ (uq pos)) (uq res)))))))

(def mulf (macro extern (val res)
  (let ((pos \ (make-gensym-var-node mc)))
    (qq let (((uq pos) \ (uq val)))
      (setf (uq pos) (* (@ (uq pos)) (uq res)))))))

(def divf (macro extern (val res)
  (let ((pos \ (make-gensym-var-node mc)))
    (qq let (((uq pos) \ (uq val)))
      (setf (uq pos) (/ (@ (uq pos)) (uq res)))))))
)

