(module util)

(import macros)
(import cstdlib)

#|
@macro mexit

Stops the compiliation of program.
Useful for debug reasons, when you know some error appears before this macro is expanded.

|#
(using-namespace std
(def mexit (macro extern (void)
  (exit 1)
  (q 0)))
)




(using-namespace std.macros


(def is-zero (fn extern bool ((a float))
  (= a 0.0)))

(def /0 (macro extern (x y)
  (qq if (is-zero (uq y))
    (* (uq x) (uq y))
    (/ (uq x) (uq y)))))

(def when (macro extern (con ...)
  (qq if (uq con) (do (uql (get-varargs-list (- (arg-count mc) 1)))) false)))

(def in (macro extern (name value ...)
  (let ((en \ (make-gensym-var-node mc))
        (bn \ (make-gensym-var-node mc))
        (val \ (make-gensym-var-node mc)))
    (qq for ( #| ((uq val) \ (move (uq value))) |# ((uq bn) \ (begin (uq value))) ((uq en) \ (end (uq value))))
            (< (uq bn) (uq en))
            (setv (uq bn) (successor (uq bn)))
      (let (((uq name) \ (source (uq bn))))
        (uql (get-varargs-list (- (arg-count mc) 2))))))))
)


(def def-type-macro2
  (macro extern (name)
    (let ((buf (array-of 250 char)))
      (sprintf buf "\"%s\"" (@:@ name token-str))
      (let ((string \ (std.macros.mnfv mc buf)))
        (std.macros.qq do
          (def (uq name)
            (macro extern (T U)
              (let ((typename (array-of 250 char)))
                (and (not (make-type-string mc (uq string) T U typename))
                     (return T))
                (def n (var auto (p DNode) (mnfv mc typename)))
(return n)))))))))

(using-namespace std.macros

(def ignore (macro extern (...)
  (qq no-op)))

(def def-ptr-macro (macro extern (name linkage type)
  (qq using-namespace std.macros
    (def (uq name) (macro (uq linkage) ((value (p (uq type))))
      (qq (uq name) (@ (uq (uq value)))))))))

(def def-ptr-macro2 (macro extern (name linkage type)
  (qq using-namespace std.macros
    (def (uq name) (macro (uq linkage) ((value1 (p (uq type))) (value2 (p (uq type))))
      (qq (uq name) (@ (uq (uq value1))) (@ (uq (uq value2)))))))))

(def macro-print (macro extern (object)
  (print object)
  (printf "\n")
  (qq no-op)))

(ignore def arg-list-names (fn extern (retval (p DNode)) ((mc (p MContext)) (form (p DNode)))
  (setf retval (copy mc true form))
  (def last-node (var auto \ (nullptr (p DNode))))
  (walk-nodes (@ retval) mc (cast last-node (p void))
    (fn int ((form (p DNode)) (mc (p MContext)) (data (p void)))
      (def last-node (var auto (p (p DNode)) (cast data (p (p DNode)))))
      (if (= 0 (@:@ form is-list)) 0
        (do (setf (:@ form is-list) 0)
            (setf (:@ form token-str) (@:@ (@:@ form list-node) token-str))
            (if (not (null (@ last-node)))
                (setf (:@ (@ last-node) next-node) form)
                0)
            (setf last-node form)
            0))))))

(ignore def defc (macro extern (name linkage cname type args)
  (let ((arg-list \ (arg-list-names mc args))
        (fdef \ (qq (uq cname) (uql arg-list))))
    (print fdef)
    (printf "\n")
    (qq do
      (def (uq cname) (fn extern-c (uq type) (uq args)))
      (def (uq name) (fn (uq linkage) (uq type) (uq args)
        ((uq cname) (uql arg-list))))))))

(def defc (macro extern (name linkage cname type args)
  (let ((fdef \ (qq (uq cname))))
    (qq do
      (def (uq cname) (fn extern-c (uq type) (uq args)))
      (def (uq name) (fn (uq linkage) (uq type) (uq args)
        (uq fdef)))))))

(def defc (macro extern (name linkage cname type args ...)
  (let ((arg-list \ (get-varargs-list (- (arg-count mc) 5)))
        (fdef \ (if (null arg-list) (qq (uq cname)) (qq (uq cname) (uql arg-list)))))
    ;(print fdef)
    ;(printf "\n")
    (qq do
      (def (uq cname) (fn extern-c (uq type) (uq args)))
      (def (uq name) (fn (uq linkage) (uq type) (uq args)
        (uq fdef)))))))


(def defc-multi (macro extern (name linkage)
  (qq no-op)))

(def defc-multi (macro extern (name linkage def0 ...)
  (qq do
    (defc (uq name) (uq linkage) (uql def0))
    (defc-multi (uq name) (uq linkage) (get-varargs-list (- (arg-count mc) 3))))))





(def incf (macro extern (val res)
  (let ((pos \ (make-gensym-var-node mc)))
    (qq let (((uq pos) \ (uq val)))
      (setf (uq pos) (+ (@ (uq pos)) (uq res)))))))

(def decf (macro extern (val res)
  (let ((pos \ (make-gensym-var-node mc)))
    (qq let (((uq pos) \ (uq val)))
      (setf (uq pos) (- (@ (uq pos)) (uq res)))))))

(def mulf (macro extern (val res)
  (let ((pos \ (make-gensym-var-node mc)))
    (qq let (((uq pos) \ (uq val)))
      (setf (uq pos) (* (@ (uq pos)) (uq res)))))))

(def divf (macro extern (val res)
  (let ((pos \ (make-gensym-var-node mc)))
    (qq let (((uq pos) \ (uq val)))
      (setf (uq pos) (/ (@ (uq pos)) (uq res)))))))
)

